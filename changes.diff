diff --git a/src/App.tsx b/src/App.tsx
index 1e2259a..541588e 100644
--- a/src/App.tsx
+++ b/src/App.tsx
@@ -1,4 +1,4 @@
-import { useEffect, useState, useCallback } from 'react';
+import { useEffect, useState } from 'react';
 import * as VIAM from "@viamrobotics/sdk";
 import AppInterface from './AppInterface';
 import Cookies from "js-cookie";
@@ -15,10 +15,11 @@ function App() {
   const [passSummaries, setPassSummaries] = useState<Pass[]>([]);
   const [files, setFiles] = useState<Map<string, VIAM.dataApi.BinaryData>>(new Map());
   const [videoFiles, setVideoFiles] = useState<Map<string, VIAM.dataApi.BinaryData>>(new Map());
+  const [imageFiles, setImageFiles] = useState<Map<string, VIAM.dataApi.BinaryData>>(new Map());
   const [viamClient, setViamClient] = useState<VIAM.ViamClient | null>(null);
   const [robotClient, setRobotClient] = useState<VIAM.RobotClient | null>(null);
   const [fetchTimestamp, setFetchTimestamp] = useState<Date | null>(null);
-  const [loadingPasses, setLoadingPasses] = useState<Set<string>>(new Set());
+  const [loadingPasses] = useState<Set<string>>(new Set());
 
   const machineNameMatch = window.location.pathname.match(machineNameRegex);
   const machineName = machineNameMatch ? machineNameMatch[1] : null;
@@ -58,10 +59,10 @@ function App() {
     while (true) {
       let binaryData = await viamClient.dataClient.binaryDataByFilter(
         filter,
-        100, // limit
+        100,
         VIAM.dataApi.Order.DESCENDING,
         paginationToken,
-        false,
+        false, // includeBinary
         false,
         false
       );
@@ -69,14 +70,22 @@ function App() {
       // Process files once and build both files and videoFiles lists
       const newFiles = new Map<string, VIAM.dataApi.BinaryData>();
       const newVideoFiles = new Map<string, VIAM.dataApi.BinaryData>();
+      const newImages = new Map<string, VIAM.dataApi.BinaryData>();
       
       binaryData.data.forEach(file => {
         if (file.metadata?.binaryDataId) {
-          if (file.metadata.fileName?.toLowerCase().includes('.mp4')) {
+          const isVideo = file.metadata.fileName?.toLowerCase().includes('.mp4');
+          const isImageFile = file.metadata.fileName?.toLowerCase().match(/\.(png|jpg|jpeg)$/);
+          const isCameraCapture = file.metadata.captureMetadata?.componentName && file.metadata.captureMetadata?.methodName;
+
+          if (isVideo) {
             // Video files go to videoFiles
             newVideoFiles.set(file.metadata.binaryDataId, file);
+          } else if (isImageFile || isCameraCapture) {
+            // Image files go to images
+            newImages.set(file.metadata.binaryDataId, file);
           } else {
-            // Non-video files go to files
+            // Other files go to files
             newFiles.set(file.metadata.binaryDataId, file);
           }
         }
@@ -104,6 +113,14 @@ function App() {
         });
         return updatedVideoFiles;
       });
+
+      setImageFiles(prevImageFiles => {
+        const updatedImageFiles = new Map(prevImageFiles);
+        newImages.forEach((file, id) => {
+          updatedImageFiles.set(id, file);
+        });
+        return updatedImageFiles;
+      });
       
       // Break if no more data to fetch
       if (!binaryData.last) break;
@@ -207,6 +224,7 @@ function App() {
       passSummaries={passSummaries}
       files={files}
       videoFiles={videoFiles}
+      imageFiles={imageFiles}
       robotClient={robotClient}
       fetchVideos={fetchFiles}
       loadingPasses={loadingPasses}
diff --git a/src/AppInterface.tsx b/src/AppInterface.tsx
index 7b243be..0e81bbc 100644
--- a/src/AppInterface.tsx
+++ b/src/AppInterface.tsx
@@ -1,4 +1,4 @@
-import React, { useState, useEffect, useMemo, useCallback } from 'react';
+import React, { useState, useEffect } from 'react';
 import * as VIAM from "@viamrobotics/sdk";
 import './AppInterface.css';
 import StepVideosGrid from './StepVideosGrid';
@@ -11,6 +11,7 @@ interface AppViewProps {
   passSummaries?: any[];
   files: Map<string, VIAM.dataApi.BinaryData>;
   videoFiles: Map<string, VIAM.dataApi.BinaryData>;
+  imageFiles: Map<string, VIAM.dataApi.BinaryData>;
   viamClient: VIAM.ViamClient;
   robotClient?: VIAM.RobotClient | null;
   fetchVideos: (start: Date) => Promise<void>;
@@ -35,12 +36,178 @@ export interface Pass {
   err_string?: string | null;
 }
 
+const ImageDisplay: React.FC<{ binaryData: VIAM.dataApi.BinaryData, viamClient: VIAM.ViamClient }> = ({ binaryData, viamClient }) => {
+  const [imageUrl, setImageUrl] = useState<string | null>(null);
+  const [isLoading, setIsLoading] = useState(true);
+  const [hasError, setHasError] = useState(false);
+  const [errorMessage, setErrorMessage] = useState<string>('');
+
+  useEffect(() => {
+    let isMounted = true;
+    let currentObjectUrl: string | null = null;
+
+    const getImageUrl = async (binaryData: VIAM.dataApi.BinaryData): Promise<void> => {
+      try {
+        let data = binaryData.binary;
+        const binaryId = binaryData.metadata?.binaryDataId;
+
+        // If binary data is not present, fetch it by ID
+        if ((!data || data.length === 0) && binaryId) {
+          console.log('Fetching binary data by ID:', binaryId);
+          const results = await viamClient.dataClient.binaryDataByIds([binaryId]);
+          if (results && results.length > 0 && results[0].binary && results[0].binary.length > 0) {
+            console.log(`Retrieved binary data for ID ${binaryId}, size:`, results[0].binary.length);
+            data = results[0].binary;
+          } else {
+            console.error(`Failed to retrieve binary data for ID ${binaryId}`);
+          }
+        }
+
+        if (!data || data.length === 0) {
+          const errMsg = `No binary data available for image ${binaryData.metadata?.fileName || binaryId}`;
+          console.error(errMsg);
+          throw new Error(errMsg);
+        }
+
+        console.log('Binary data size:', data.length);
+
+        // Determine MIME type based on file extension or metadata
+        let mimeType = 'image/jpeg'; // default
+        const fileName = binaryData.metadata?.fileName?.toLowerCase();
+        const fileExt = binaryData.metadata?.fileExt?.toLowerCase();
+        
+        if (fileName?.endsWith('.png') || fileExt === 'png') {
+          mimeType = 'image/png';
+        } else if (fileName?.endsWith('.jpg') || fileName?.endsWith('.jpeg') || fileExt === 'jpg' || fileExt === 'jpeg') {
+          mimeType = 'image/jpeg';
+        }
+
+        console.log('Using MIME type:', mimeType);
+
+        // Don't try to create a blob with empty data
+        if (data.length === 0) {
+          throw new Error('Cannot create image from empty data');
+        }
+
+        // Convert Uint8Array to blob
+        const buffer = new ArrayBuffer(data.length);
+        const view = new Uint8Array(buffer);
+        view.set(data);
+        
+        const blob = new Blob([buffer], { type: mimeType });
+        currentObjectUrl = URL.createObjectURL(blob);
+        
+        console.log('Created blob URL:', currentObjectUrl);
+        
+        if (isMounted) {
+          setImageUrl(currentObjectUrl);
+          setIsLoading(false);
+          setHasError(false);
+          setErrorMessage('');
+        }
+      } catch (error) {
+        const errorMsg = error instanceof Error ? error.message : 'Unknown error';
+        console.error("Error creating image URL:", errorMsg);
+        if (isMounted) {
+          setImageUrl(null);
+          setIsLoading(false);
+          setHasError(true);
+          setErrorMessage(errorMsg);
+        }
+      }
+    };
+
+    getImageUrl(binaryData);
+
+    return () => {
+      isMounted = false;
+      // Clean up the object URL when component unmounts
+      if (currentObjectUrl) {
+        console.log('Revoking blob URL:', currentObjectUrl);
+        URL.revokeObjectURL(currentObjectUrl);
+      }
+    };
+  }, [binaryData, viamClient]);
+
+  if (isLoading) {
+    return (
+      <div style={{ 
+        width: '300px', 
+        height: '225px', 
+        backgroundColor: '#f0f0f0', 
+        borderRadius: '4px',
+        display: 'flex',
+        alignItems: 'center',
+        justifyContent: 'center',
+        color: '#6b7280'
+      }}>
+        Loading...
+      </div>
+    );
+  }
+
+  if (hasError || !imageUrl) {
+    return (
+      <div style={{ 
+        width: '300px', 
+        height: '225px', 
+        backgroundColor: '#f0f0f0', 
+        borderRadius: '4px',
+        display: 'flex',
+        flexDirection: 'column',
+        alignItems: 'center',
+        justifyContent: 'center',
+        color: '#ef4444',
+        fontSize: '14px',
+        textAlign: 'center',
+        padding: '20px'
+      }}>
+        <div>Failed to load image</div>
+        {errorMessage && (
+          <div style={{ fontSize: '12px', marginTop: '8px', color: '#9ca3af', maxWidth: '260px', overflow: 'hidden', textOverflow: 'ellipsis' }}>
+            {errorMessage}
+          </div>
+        )}
+        {binaryData.metadata?.fileName && (
+          <div style={{ fontSize: '12px', marginTop: '8px', color: '#9ca3af' }}>
+            {binaryData.metadata.fileName.split('/').pop()}
+          </div>
+        )}
+      </div>
+    );
+  }
+
+  return (
+    <img 
+      src={imageUrl} 
+      alt="Pass capture" 
+      style={{ 
+        width: '100%',
+        maxWidth: '100%',
+        maxHeight: '225px',
+        borderRadius: '4px',
+        objectFit: 'contain',
+        display: 'block'
+      }} 
+      onLoad={() => {
+        console.log('Image loaded successfully');
+      }}
+      onError={() => {
+        console.error("Image failed to render, URL:", imageUrl);
+        setHasError(true);
+        setErrorMessage('Image failed to render after loading');
+      }}
+    />
+  );
+};
+
 const AppInterface: React.FC<AppViewProps> = ({ 
   machineName,
   viamClient,
   passSummaries = [],
   files, 
   videoFiles,
+  imageFiles,
   robotClient,
   fetchVideos,
   fetchTimestamp,
@@ -48,6 +215,15 @@ const AppInterface: React.FC<AppViewProps> = ({
   const [activeRoute, setActiveRoute] = useState('live');
   const [expandedRows, setExpandedRows] = useState<Set<number>>(new Set());
   const [videoStoreClient, setVideoStoreClient] = useState<VIAM.GenericComponentClient | null>(null);
+  const [selectedCamera, setSelectedCamera] = useState<string>('');
+
+  const cameraComponentNames = Array.from(
+    new Set(
+      Array.from(imageFiles.values())
+        .map(file => file.metadata?.captureMetadata?.componentName)
+        .filter((name): name is string => !!name)
+    )
+  );
 
   const activeTabStyle = "bg-blue-600 text-white";
   const inactiveTabStyle = "bg-gray-200 text-gray-700 hover:bg-gray-300";
@@ -130,6 +306,25 @@ const AppInterface: React.FC<AppViewProps> = ({
               robotClient={robotClient || null}
               onVideoStoreSelected={setVideoStoreClient}
             />
+
+            {cameraComponentNames.length > 0 && (
+              <div className="mb-4">
+                <label htmlFor="camera-select" className="block text-sm font-medium text-gray-700 mb-2">
+                  Select Camera for Before/After Images
+                </label>
+                <select
+                  id="camera-select"
+                  value={selectedCamera}
+                  onChange={(e) => setSelectedCamera(e.target.value)}
+                  className="block w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-blue-500 focus:border-blue-500"
+                >
+                  <option value="">-- Select a Camera --</option>
+                  {cameraComponentNames.map(name => (
+                    <option key={name} value={name}>{name}</option>
+                  ))}
+                </select>
+              </div>
+            )}
             
             <div className="viam-table-container">
               <table className="viam-table">
@@ -205,40 +400,150 @@ const AppInterface: React.FC<AppViewProps> = ({
                             <div className="pass-details">
                               <div className="passes-container">
                                 <div className="steps-grid">
+                                  {/* Before Image - with time threshold */}
+                                  {selectedCamera && (() => {
+                                    const passStart = new Date(pass.start);
+                                    
+                                    const allCameraImages = Array.from(imageFiles.values()).filter(file => 
+                                      file.metadata?.captureMetadata?.componentName === selectedCamera && file.metadata?.timeRequested
+                                    ).sort((a, b) => a.metadata!.timeRequested!.toDate().getTime() - b.metadata!.timeRequested!.toDate().getTime());
+                                    
+                                    const beforeImage = allCameraImages
+                                      .filter(img => {
+                                        const imgTime = img.metadata!.timeRequested!.toDate();
+                                        return imgTime < passStart; // No minimum time restriction
+                                      })
+                                      .pop(); // Get the last one (most recent before pass start)
+                                    
+                                    // If no image within threshold, show a message instead
+                                    if (!beforeImage) {
+                                      return (
+                                        <div className="step-card" style={{ order: -1 }}>
+                                          <div className="step-name">Before Image</div>
+                                          <div className="step-duration" style={{ color: '#6b7280' }}>No recent image available</div>
+                                          <div style={{ 
+                                            height: '225px',
+                                            display: 'flex',
+                                            alignItems: 'center',
+                                            justifyContent: 'center',
+                                            backgroundColor: '#f3f4f6',
+                                            borderRadius: '4px',
+                                            marginTop: '12px',
+                                            color: '#9ca3af',
+                                            fontSize: '14px'
+                                          }}>
+                                            No image captured within 30 minutes before pass start
+                                          </div>
+                                        </div>
+                                      );
+                                    }
+                                    
+                                    return (
+                                      <div className="step-card" style={{ order: -1 }}>
+                                        <div className="step-name">Before Image</div>
+                                        <div className="step-duration">
+                                          {beforeImage.metadata?.timeRequested?.toDate().toLocaleTimeString()}
+                                          <span style={{ fontSize: '12px', color: '#6b7280', marginLeft: '8px' }}>
+                                            ({Math.round((passStart.getTime() - (beforeImage.metadata?.timeRequested?.toDate()?.getTime() || passStart.getTime())) / 60000)}m before pass)
+                                          </span>
+                                        </div>
+                                        
+                                        <div className="step-image-container" style={{ marginTop: "12px", width: "100%", overflow: "hidden" }}>
+                                          <ImageDisplay binaryData={beforeImage} viamClient={viamClient} />
+                                        </div>
+                                      </div>
+                                    );
+                                  })()}
+                                  
+                                  {/* Regular step cards */}
                                   {pass.steps.map((step: Step) => {
-                                      const stepVideos = getStepVideos(step);
+                                    const stepVideos = getStepVideos(step);
 
+                                    return (
+                                      <div key={step.name} className="step-card">
+                                        <div className="step-name">{step.name}</div>
+                                        <div className="step-timeline">
+                                          <div className="step-time">
+                                            <span className="time-label">Start</span>
+                                            <span className="time-value">{step.start.toLocaleTimeString()}</span>
+                                          </div>
+                                          <div className="timeline-arrow">→</div>
+                                          <div className="step-time">
+                                            <span className="time-label">End</span>
+                                            <span className="time-value">{step.end.toLocaleTimeString()}</span>
+                                          </div>
+                                        </div>
+                                        <div className="step-duration">{formatDurationToMinutesSeconds(step.start, step.end)}</div>
+                                        
+                                        <StepVideosGrid
+                                          step={step}
+                                          stepVideos={stepVideos}
+                                          videoFiles={videoFiles}
+                                          fetchTimestamp={fetchTimestamp}
+                                          videoStoreClient={videoStoreClient}
+                                          viamClient={viamClient}
+                                          fetchVideos={fetchVideos}
+                                        />
+                                      </div>
+                                    );
+                                  })}
+
+                                  {/* After Image - with time threshold */}
+                                  {selectedCamera && (() => {
+                                    const passEnd = new Date(pass.end);
+                                    
+                                    const allCameraImages = Array.from(imageFiles.values()).filter(file => 
+                                      file.metadata?.captureMetadata?.componentName === selectedCamera && file.metadata?.timeRequested
+                                    ).sort((a, b) => a.metadata!.timeRequested!.toDate().getTime() - b.metadata!.timeRequested!.toDate().getTime());
+                                    
+                                    // Only consider images taken after pass end, with no maximum time restriction
+                                    const afterImage = allCameraImages.find(img => {
+                                      const imgTime = img.metadata!.timeRequested!.toDate();
+                                      return imgTime > passEnd; // No maximum time restriction
+                                    });
+                                    
+                                    // If no image within threshold, show a message instead
+                                    if (!afterImage) {
                                       return (
-                                        <div key={step.name} className="step-card">
-                                          <div className="step-name">{step.name}</div>
-                                          <div className="step-timeline">
-                                            <div className="step-time">
-                                              <span className="time-label">Start</span>
-                                              <span className="time-value">{step.start.toLocaleTimeString()}</span>
-                                            </div>
-                                            <div className="timeline-arrow">→</div>
-                                            <div className="step-time">
-                                              <span className="time-label">End</span>
-                                              <span className="time-value">{step.end.toLocaleTimeString()}</span>
-                                            </div>
+                                        <div className="step-card" style={{ order: 999 }}>
+                                          <div className="step-name">After Image</div>
+                                          <div className="step-duration" style={{ color: '#6b7280' }}>No recent image available</div>
+                                          <div style={{ 
+                                            height: '225px',
+                                            display: 'flex',
+                                            alignItems: 'center',
+                                            justifyContent: 'center',
+                                            backgroundColor: '#f3f4f6',
+                                            borderRadius: '4px',
+                                            marginTop: '12px',
+                                            color: '#9ca3af',
+                                            fontSize: '14px'
+                                          }}>
+                                            No image captured within 30 minutes after pass end
                                           </div>
-                                          <div className="step-duration">{formatDurationToMinutesSeconds(step.start, step.end)}</div>
-                                          
-                                          <StepVideosGrid
-                                            step={step}
-                                            stepVideos={stepVideos}
-                                            videoFiles={videoFiles}
-                                            fetchTimestamp={fetchTimestamp}
-                                            videoStoreClient={videoStoreClient}
-                                            viamClient={viamClient}
-                                            fetchVideos={fetchVideos}
-                                          />
                                         </div>
                                       );
-                                  })}
+                                    }
+                                    
+                                    return (
+                                      <div className="step-card" style={{ order: 999 }}>
+                                        <div className="step-name">After Image</div>
+                                        <div className="step-duration">
+                                          {afterImage.metadata?.timeRequested?.toDate().toLocaleTimeString()}
+                                          <span style={{ fontSize: '12px', color: '#6b7280', marginLeft: '8px' }}>
+                                            ({Math.round(((afterImage.metadata?.timeRequested?.toDate()?.getTime() || passEnd.getTime()) - passEnd.getTime()) / 60000)}m after pass)
+                                          </span>
+                                        </div>
+                                        
+                                        <div className="step-image-container" style={{ marginTop: "12px", width: "100%", overflow: "hidden" }}>
+                                          <ImageDisplay binaryData={afterImage} viamClient={viamClient} />
+                                        </div>
+                                      </div>
+                                    );
+                                  })()}
                                 </div>
                               
-                                {/* New section for all files in pass time range */}
+                                {/* Keep the "all files in pass time range" section unchanged */}
                                 {(() => {
                                   const passStart = new Date(pass.start);
                                   const passEnd = new Date(pass.end);
diff --git a/src/StepVideosGrid.tsx b/src/StepVideosGrid.tsx
index 3c70678..0adaae1 100644
--- a/src/StepVideosGrid.tsx
+++ b/src/StepVideosGrid.tsx
@@ -1,4 +1,3 @@
-
 import React, { useState, useEffect, useRef } from "react";
 import * as VIAM from "@viamrobotics/sdk";
 import VideoModal from "./VideoModal";
@@ -134,70 +133,74 @@ const StepVideosGrid: React.FC<StepVideosGridProps> = ({
   if (stepVideos.length === 0) {
     return (
       <>
-        <div className="generate video">
-          <button
-            className="generate-video-button"
-            onClick={() => handleGenerateVideo()}
-
-            disabled={videoStoreClient == null || isPolling}
-            style={{
-              padding: '8px 16px',
-              backgroundColor: videoStoreClient && !isPolling ? '#3b82f6' : '#9ca3af',
-              color: 'white',
-              border: 'none',
-              borderRadius: '4px',
-              cursor: videoStoreClient && !isPolling ? 'pointer' : 'not-allowed',
-              fontSize: '14px',
-              transition: 'background-color 0.2s',
-              display: 'flex',
-              alignItems: 'center',
-              gap: '8px',
-              minWidth: '140px',
-              justifyContent: 'center'
-            }}
-            onMouseEnter={(e) => {
-              if (videoStoreClient && !isPolling) {
-                e.currentTarget.style.backgroundColor = '#2563eb';
-              }
-            }}
-            onMouseLeave={(e) => {
-
-              if (videoStoreClient && !isPolling) {
-                e.currentTarget.style.backgroundColor = '#3b82f6';
-              }
-            }}
-                      >
-              {isPolling ? (
-                <>
-                  <div 
-                    style={{
-                      width: '16px',
-                      height: '16px',
-                      border: '2px solid #ffffff',
-                      borderTop: '2px solid transparent',
-                      borderRadius: '50%',
-                      animation: 'spin 1s linear infinite'
-                    }}
-                  />
-                  Generating...
-                </>
-              ) : (
-                'Generate Video'
-              )}
-            </button>
-                      {isPolling && (
+      <div className="generate-video" style={{ 
+        display: 'flex', 
+        flexDirection: 'column', 
+        alignItems: 'center', 
+        justifyContent: 'center',
+        marginTop: '18px'
+      }}>
+        <button
+          className="generate-video-button"
+          onClick={() => handleGenerateVideo()}
+          disabled={videoStoreClient == null || isPolling}
+          style={{
+            padding: '8px 16px',
+            backgroundColor: videoStoreClient && !isPolling ? '#3b82f6' : '#9ca3af',
+            color: 'white',
+            border: 'none',
+            borderRadius: '4px',
+            cursor: videoStoreClient && !isPolling ? 'pointer' : 'not-allowed',
+            fontSize: '14px',
+            transition: 'background-color 0.2s',
+            display: 'flex',
+            alignItems: 'center',
+            gap: '8px',
+            minWidth: '140px',
+            justifyContent: 'center'
+          }}
+          onMouseEnter={(e) => {
+            if (videoStoreClient && !isPolling) {
+              e.currentTarget.style.backgroundColor = '#2563eb';
+            }
+          }}
+          onMouseLeave={(e) => {
+            if (videoStoreClient && !isPolling) {
+              e.currentTarget.style.backgroundColor = '#3b82f6';
+            }
+          }}
+        >
+          {isPolling ? (
+            <>
               <div 
                 style={{
-                  marginTop: '8px',
-                  fontSize: '12px',
-                  color: '#6b7280',
-                  textAlign: 'center'
+                  width: '16px',
+                  height: '16px',
+                  border: '2px solid #ffffff',
+                  borderTop: '2px solid transparent',
+                  borderRadius: '50%',
+                  animation: 'spin 1s linear infinite'
                 }}
-              >
-                This can take up to a minute.
-              </div>
-            )}
-        </div>
+              />
+              Generating...
+            </>
+          ) : (
+            'Generate Video'
+          )}
+        </button>
+        {isPolling && (
+          <div 
+            style={{
+              marginTop: '8px',
+              fontSize: '12px',
+              color: '#6b7280',
+              textAlign: 'center'
+            }}
+          >
+            This can take up to a minute.
+          </div>
+        )}
+      </div>
       </>
     );
   }
