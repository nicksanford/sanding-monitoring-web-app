diff --git a/src/AppInterface.tsx b/src/AppInterface.tsx
index 2d0e6a2..c503026 100644
--- a/src/AppInterface.tsx
+++ b/src/AppInterface.tsx
@@ -65,8 +65,91 @@ const AppInterface: React.FC<AppViewProps> = ({
     setExpandedRows(newExpandedRows);
   };
 
-  const handleCameraSelected = (client: VIAM.CameraClient | null, resourceName: string | null) => {
+  const handleCameraSelected = async (client: VIAM.CameraClient | null, resourceName: string | null) => {
     console.log('Camera selected:', resourceName, client ? 'connected' : 'disconnected');
+    
+    // Fetch and log binary data for the selected camera
+    if (resourceName && viamClient && robotClient) {
+      try {
+        console.log(`Fetching binary data for camera: ${resourceName}`);
+        
+        // Create a filter that combines component name and time range
+        const startDate = new Date('2025-01-01T00:00:00Z'); // Go back to Jan 1, 2025
+        const endDate = new Date(); // current time
+        
+        console.log(`Filtering from ${startDate.toISOString()} to ${endDate.toISOString()}`);
+        
+        const filter = new VIAM.dataApi.Filter({
+          componentName: resourceName,
+          componentType: 'camera',
+          interval: {
+            start: VIAM.Timestamp.fromDate(startDate),
+            end: VIAM.Timestamp.fromDate(endDate),
+          } as VIAM.dataApi.CaptureInterval,
+        });
+        
+        const allBinaryData: VIAM.dataApi.BinaryData[] = [];
+        let nextToken: string | undefined = undefined;
+        const maxEntries = 100;
+        
+        // Make multiple requests to get up to 100 entries
+        // Since includeBinaryData=true requires limit=1, we'll make multiple calls
+        for (let i = 0; i < maxEntries; i++) {
+          try {
+            const binaryDataResponse = await viamClient.dataClient.binaryDataByFilter(
+              filter,
+              1, // limit must be 1 when includeBinaryData is true
+              VIAM.dataApi.Order.DESCENDING,
+              nextToken, // pagination token
+              true, // includeBinaryData
+              false, // countOnly
+              false // includeInternalData
+            );
+            
+            if (binaryDataResponse.data.length === 0) {
+              break; // No more data available
+            }
+            
+            allBinaryData.push(...binaryDataResponse.data);
+            nextToken = binaryDataResponse.last;
+            
+            // If no more pages, break
+            if (!nextToken) {
+              break;
+            }
+          } catch (pageError) {
+            console.error(`Error fetching page ${i + 1}:`, pageError);
+            break;
+          }
+        }
+        
+        console.log(`Found ${allBinaryData.length} binary data entries for camera ${resourceName}`);
+        
+        // Log each binary data entry
+        allBinaryData.forEach((data, index) => {
+          console.log(`Binary Data Entry ${index + 1}:`, {
+            id: data.metadata?.binaryDataId,
+            fileName: data.metadata?.fileName,
+            timeRequested: data.metadata?.timeRequested?.toDate(),
+            timeReceived: data.metadata?.timeReceived?.toDate(),
+            uri: data.metadata?.uri,
+            sizeBytes: data.binary?.length || 0,
+            fileExtension: data.metadata?.fileExt,
+            annotations: data.metadata?.annotations
+          });
+        });
+        
+        // Log summary
+        console.log('Binary Data Summary:', {
+          fetchedEntries: allBinaryData.length,
+          requestsMade: Math.min(allBinaryData.length, maxEntries),
+          hasMoreData: !!nextToken
+        });
+        
+      } catch (error) {
+        console.error(`Error fetching binary data for camera ${resourceName}:`, error);
+      }
+    }
   };
 
   const getStepVideos = (step: Step) => {
