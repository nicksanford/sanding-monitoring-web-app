diff --git a/changes.diff b/changes.diff
new file mode 100644
index 0000000..e69de29
diff --git a/src/App.tsx b/src/App.tsx
index 1e2259a..9495800 100644
--- a/src/App.tsx
+++ b/src/App.tsx
@@ -1,4 +1,4 @@
-import { useEffect, useState, useCallback } from 'react';
+import { useEffect, useState } from 'react';
 import * as VIAM from "@viamrobotics/sdk";
 import AppInterface from './AppInterface';
 import Cookies from "js-cookie";
@@ -18,7 +18,7 @@ function App() {
   const [viamClient, setViamClient] = useState<VIAM.ViamClient | null>(null);
   const [robotClient, setRobotClient] = useState<VIAM.RobotClient | null>(null);
   const [fetchTimestamp, setFetchTimestamp] = useState<Date | null>(null);
-  const [loadingPasses, setLoadingPasses] = useState<Set<string>>(new Set());
+  const [loadingPasses] = useState<Set<string>>(new Set());
 
   const machineNameMatch = window.location.pathname.match(machineNameRegex);
   const machineName = machineNameMatch ? machineNameMatch[1] : null;
@@ -114,7 +114,7 @@ function App() {
     setFetchTimestamp(null)
   };
 
-  useEffect(() => {
+    useEffect(() => {
     const fetchPasses = async () => {
       console.log("Fetching data start");
 
@@ -191,15 +191,6 @@ function App() {
       fetchPasses();
     }, [apiKeyId, apiKeySecret, hostname, machineId, locationId]);
 
-
-  // Fetch videos when passSummaries and viamClient are available
-  useEffect(() => {
-    if (passSummaries.length > 0 && viamClient) {
-      const earliestVideoTime = passSummaries[passSummaries.length - 1].start;
-      fetchFiles(earliestVideoTime);
-    }
-  }, [passSummaries, viamClient]);
-
   return (
     <AppInterface 
       machineName={machineName}
diff --git a/src/AppInterface.tsx b/src/AppInterface.tsx
index 7b243be..c503026 100644
--- a/src/AppInterface.tsx
+++ b/src/AppInterface.tsx
@@ -1,8 +1,9 @@
-import React, { useState, useEffect, useMemo, useCallback } from 'react';
+import React, { useState } from 'react';
 import * as VIAM from "@viamrobotics/sdk";
 import './AppInterface.css';
 import StepVideosGrid from './StepVideosGrid';
 import VideoStoreSelector from './VideoStoreSelector';
+import CameraSelector from './CameraSelector';
 import { 
   formatDurationToMinutesSeconds,
 } from './lib/videoUtils';
@@ -64,6 +65,93 @@ const AppInterface: React.FC<AppViewProps> = ({
     setExpandedRows(newExpandedRows);
   };
 
+  const handleCameraSelected = async (client: VIAM.CameraClient | null, resourceName: string | null) => {
+    console.log('Camera selected:', resourceName, client ? 'connected' : 'disconnected');
+    
+    // Fetch and log binary data for the selected camera
+    if (resourceName && viamClient && robotClient) {
+      try {
+        console.log(`Fetching binary data for camera: ${resourceName}`);
+        
+        // Create a filter that combines component name and time range
+        const startDate = new Date('2025-01-01T00:00:00Z'); // Go back to Jan 1, 2025
+        const endDate = new Date(); // current time
+        
+        console.log(`Filtering from ${startDate.toISOString()} to ${endDate.toISOString()}`);
+        
+        const filter = new VIAM.dataApi.Filter({
+          componentName: resourceName,
+          componentType: 'camera',
+          interval: {
+            start: VIAM.Timestamp.fromDate(startDate),
+            end: VIAM.Timestamp.fromDate(endDate),
+          } as VIAM.dataApi.CaptureInterval,
+        });
+        
+        const allBinaryData: VIAM.dataApi.BinaryData[] = [];
+        let nextToken: string | undefined = undefined;
+        const maxEntries = 100;
+        
+        // Make multiple requests to get up to 100 entries
+        // Since includeBinaryData=true requires limit=1, we'll make multiple calls
+        for (let i = 0; i < maxEntries; i++) {
+          try {
+            const binaryDataResponse = await viamClient.dataClient.binaryDataByFilter(
+              filter,
+              1, // limit must be 1 when includeBinaryData is true
+              VIAM.dataApi.Order.DESCENDING,
+              nextToken, // pagination token
+              true, // includeBinaryData
+              false, // countOnly
+              false // includeInternalData
+            );
+            
+            if (binaryDataResponse.data.length === 0) {
+              break; // No more data available
+            }
+            
+            allBinaryData.push(...binaryDataResponse.data);
+            nextToken = binaryDataResponse.last;
+            
+            // If no more pages, break
+            if (!nextToken) {
+              break;
+            }
+          } catch (pageError) {
+            console.error(`Error fetching page ${i + 1}:`, pageError);
+            break;
+          }
+        }
+        
+        console.log(`Found ${allBinaryData.length} binary data entries for camera ${resourceName}`);
+        
+        // Log each binary data entry
+        allBinaryData.forEach((data, index) => {
+          console.log(`Binary Data Entry ${index + 1}:`, {
+            id: data.metadata?.binaryDataId,
+            fileName: data.metadata?.fileName,
+            timeRequested: data.metadata?.timeRequested?.toDate(),
+            timeReceived: data.metadata?.timeReceived?.toDate(),
+            uri: data.metadata?.uri,
+            sizeBytes: data.binary?.length || 0,
+            fileExtension: data.metadata?.fileExt,
+            annotations: data.metadata?.annotations
+          });
+        });
+        
+        // Log summary
+        console.log('Binary Data Summary:', {
+          fetchedEntries: allBinaryData.length,
+          requestsMade: Math.min(allBinaryData.length, maxEntries),
+          hasMoreData: !!nextToken
+        });
+        
+      } catch (error) {
+        console.error(`Error fetching binary data for camera ${resourceName}:`, error);
+      }
+    }
+  };
+
   const getStepVideos = (step: Step) => {
     if (!videoFiles || videoFiles.size === 0) return [];
     
@@ -131,6 +219,11 @@ const AppInterface: React.FC<AppViewProps> = ({
               onVideoStoreSelected={setVideoStoreClient}
             />
             
+            <CameraSelector
+              robotClient={robotClient || null}
+              onCameraSelected={handleCameraSelected}
+            />
+            
             <div className="viam-table-container">
               <table className="viam-table">
                 <thead>
diff --git a/src/CameraSelector.tsx b/src/CameraSelector.tsx
new file mode 100644
index 0000000..b65a485
--- /dev/null
+++ b/src/CameraSelector.tsx
@@ -0,0 +1,148 @@
+import React, { useState, useEffect } from 'react';
+import * as VIAM from "@viamrobotics/sdk";
+
+interface CameraSelectorProps {
+  robotClient: VIAM.RobotClient | null;
+  onCameraSelected: (client: VIAM.CameraClient | null, resourceName: string | null) => void;
+}
+
+interface CameraResource {
+  name: string;
+  type: string;
+  subtype: string;
+}
+
+const CameraSelector: React.FC<CameraSelectorProps> = ({ 
+  robotClient, 
+  onCameraSelected 
+}) => {
+  const [cameras, setCameras] = useState<CameraResource[]>([]);
+  const [selectedCamera, setSelectedCamera] = useState<string>('');
+  const [isLoading, setIsLoading] = useState(false);
+  const [error, setError] = useState<string | null>(null);
+
+  // Fetch available camera resources when robotClient changes
+  useEffect(() => {
+    const fetchCameras = async () => {
+      if (!robotClient) {
+        setCameras([]);
+        return;
+      }
+
+      setIsLoading(true);
+      setError(null);
+
+      try {
+        // Get resource names from the robot client
+        const resourceNames = await robotClient.resourceNames();
+        
+        // Filter for camera components
+        const cameraResources = resourceNames.filter(
+          (resource: any) => 
+            resource.type === "component" && 
+            resource.subtype === "camera"
+        );
+
+        setCameras(cameraResources);
+        
+        // Clear selection when cameras change
+        setSelectedCamera('');
+        onCameraSelected(null, null);
+      } catch (err) {
+        console.error('Failed to fetch camera resources:', err);
+        setError('Failed to fetch available cameras');
+        setCameras([]);
+      } finally {
+        setIsLoading(false);
+      }
+    };
+
+    fetchCameras();
+  }, [robotClient, onCameraSelected]);
+
+  const handleCameraSelect = (resourceName: string) => {
+    setSelectedCamera(resourceName);
+    
+    // Console log the change as requested
+    console.log('Camera selected:', resourceName);
+    
+    if (resourceName && robotClient) {
+      try {
+        const cameraClient = new VIAM.CameraClient(robotClient, resourceName);
+        onCameraSelected(cameraClient, resourceName);
+        setError(null);
+      } catch (err) {
+        console.error('Failed to create camera client:', err);
+        setError(`Failed to connect to selected camera`);
+        onCameraSelected(null, null);
+      }
+    } else {
+      onCameraSelected(null, null);
+    }
+  };
+
+  if (!robotClient) {
+    return (
+      <div className="camera-selector">
+        <div className="text-gray-500 text-sm">
+          Robot not connected
+        </div>
+      </div>
+    );
+  }
+
+  return (
+    <div className="camera-selector mb-4">
+      <label htmlFor="camera-select" className="block text-sm font-medium text-gray-700 mb-2">
+        Select Camera Resource
+      </label>
+      
+      <div className="space-y-3">
+        <div className="relative">
+          <select
+            id="camera-select"
+            value={selectedCamera}
+            onChange={(e) => handleCameraSelect(e.target.value)}
+            disabled={isLoading}
+            className="block w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-blue-500 focus:border-blue-500 disabled:bg-gray-100 disabled:cursor-not-allowed"
+          >
+            <option value="">
+              {isLoading ? 'Loading cameras...' : 'Select a camera'}
+            </option>
+            {cameras.map((camera) => (
+              <option key={camera.name} value={camera.name}>
+                {camera.name}
+              </option>
+            ))}
+          </select>
+          
+          {isLoading && (
+            <div className="absolute inset-y-0 right-0 flex items-center pr-3">
+              <div className="animate-spin rounded-full h-4 w-4 border-b-2 border-blue-600"></div>
+            </div>
+          )}
+        </div>
+      </div>
+
+      {error && (
+        <div className="mt-2 text-sm text-red-600">
+          {error}
+        </div>
+      )}
+
+      {cameras.length === 0 && !isLoading && !error && (
+        <div className="mt-2 text-sm text-gray-500">
+          No camera resources found
+        </div>
+      )}
+
+      {selectedCamera && (
+        <div className="mt-2 text-sm text-green-600">
+          âœ“ Connected to: {selectedCamera}
+        </div>
+      )}
+    </div>
+  );
+};
+
+export default CameraSelector;
\ No newline at end of file
