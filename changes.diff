diff --git a/src/AppInterface.tsx b/src/AppInterface.tsx
index 9c5474f..52a0c41 100644
--- a/src/AppInterface.tsx
+++ b/src/AppInterface.tsx
@@ -78,21 +78,21 @@ const AppInterface: React.FC<AppViewProps> = ({
     const passStart = new Date(pass.start);
     const passEnd = new Date(pass.end);
     
-    const allCameraImages = Array.from(imageFiles.values()).filter(file => 
-      file.metadata?.captureMetadata?.componentName === selectedCamera && file.metadata?.timeRequested
-    ).sort((a, b) => a.metadata!.timeRequested!.toDate().getTime() - b.metadata!.timeRequested!.toDate().getTime());
+    const allCameraImages = Array.from(imageFiles.values()).filter(file => {
+      if (file.metadata?.captureMetadata?.componentName !== selectedCamera || !file.metadata?.timeRequested) {
+        return false;
+      }
+      
+      const imgTime = file.metadata.timeRequested.toDate();
+      // Only consider images within the pass time range
+      return imgTime >= passStart && imgTime <= passEnd;
+    }).sort((a, b) => a.metadata!.timeRequested!.toDate().getTime() - b.metadata!.timeRequested!.toDate().getTime());
     
-    const beforeImage = allCameraImages
-      .filter(img => {
-        const imgTime = img.metadata!.timeRequested!.toDate();
-        return imgTime < passStart;
-      })
-      .pop();
+    // Get the first image in the pass (closest to start)
+    const beforeImage = allCameraImages[0];
     
-    const afterImage = allCameraImages.find(img => {
-      const imgTime = img.metadata!.timeRequested!.toDate();
-      return imgTime > passEnd;
-    });
+    // Get the last image in the pass (closest to end)
+    const afterImage = allCameraImages[allCameraImages.length - 1];
 
     return { 
       beforeImage: beforeImage || null, 
@@ -284,51 +284,38 @@ const AppInterface: React.FC<AppViewProps> = ({
                             <div className="pass-details">
                               <div className="passes-container">
                                 <div className="steps-grid">
-                                  {/* Before Image - with time threshold */}
+                                  {/* Before Image - within pass range */}
                                   {selectedCamera && (() => {
                                     const passStart = new Date(pass.start);
+                                    const passEnd = new Date(pass.end);
                                     
-                                    const allCameraImages = Array.from(imageFiles.values()).filter(file => 
-                                      file.metadata?.captureMetadata?.componentName === selectedCamera && file.metadata?.timeRequested
-                                    ).sort((a, b) => a.metadata!.timeRequested!.toDate().getTime() - b.metadata!.timeRequested!.toDate().getTime());
+                                    const allCameraImages = Array.from(imageFiles.values()).filter(file => {
+                                      if (file.metadata?.captureMetadata?.componentName !== selectedCamera || !file.metadata?.timeRequested) {
+                                        return false;
+                                      }
+                                      const imgTime = file.metadata.timeRequested.toDate();
+                                      return imgTime >= passStart && imgTime <= passEnd;
+                                    }).sort((a, b) => a.metadata!.timeRequested!.toDate().getTime() - b.metadata!.timeRequested!.toDate().getTime());
                                     
-                                    const beforeImage = allCameraImages
-                                      .filter(img => {
-                                        const imgTime = img.metadata!.timeRequested!.toDate();
-                                        return imgTime < passStart; // No minimum time restriction
-                                      })
-                                      .pop(); // Get the last one (most recent before pass start)
+                                    const beforeImage = allCameraImages[0]; // Get the first one (closest to start)
                                     
-                                    // If no image within threshold, show a message instead
                                     if (!beforeImage) {
-                                      return (
-                                        <div className="step-card" style={{ order: -1 }}>
-                                          <div className="step-name">Before Image</div>
-                                          <div className="step-duration" style={{ color: '#6b7280' }}>No recent image available</div>
-                                          <div style={{ 
-                                            height: '225px',
-                                            display: 'flex',
-                                            alignItems: 'center',
-                                            justifyContent: 'center',
-                                            backgroundColor: '#f3f4f6',
-                                            borderRadius: '4px',
-                                            marginTop: '12px',
-                                            color: '#9ca3af',
-                                            fontSize: '14px'
-                                          }}>
-                                            No image captured before pass start
-                                          </div>
-                                        </div>
-                                      );
+                                      return null; // Don't show anything if no image in pass range
                                     }
                                     
                                     return (
                                       <div className="step-card" style={{ order: -1 }}>
-                                        <div className="step-name">Before Image</div>
+                                        <div className="step-name">Start Image</div>
                                         <div className="step-duration">
                                           {beforeImage.metadata?.timeRequested?.toDate().toLocaleTimeString()}
                                           <span style={{ fontSize: '12px', color: '#6b7280', marginLeft: '8px' }}>
-                                            ({Math.round((passStart.getTime() - (beforeImage.metadata?.timeRequested?.toDate()?.getTime() || passStart.getTime())) / 60000)}m before pass)
+                                            ({(() => {
+                                              const minutes = Math.abs(beforeImage.metadata?.timeRequested?.toDate()?.getTime() - passStart.getTime()) / 60000;
+                                              if (minutes < 1) {
+                                                return `${Math.round(minutes * 60)}s from start`;
+                                              }
+                                              return `${Math.round(minutes)}m from start`;
+                                            })()})
                                           </span>
                                         </div>
                                         
@@ -379,50 +366,38 @@ const AppInterface: React.FC<AppViewProps> = ({
                                     );
                                   })}
 
-                                  {/* After Image - with time threshold */}
+                                  {/* After Image - within pass range */}
                                   {selectedCamera && (() => {
+                                    const passStart = new Date(pass.start);
                                     const passEnd = new Date(pass.end);
                                     
-                                    const allCameraImages = Array.from(imageFiles.values()).filter(file => 
-                                      file.metadata?.captureMetadata?.componentName === selectedCamera && file.metadata?.timeRequested
-                                    ).sort((a, b) => a.metadata!.timeRequested!.toDate().getTime() - b.metadata!.timeRequested!.toDate().getTime());
+                                    const allCameraImages = Array.from(imageFiles.values()).filter(file => {
+                                      if (file.metadata?.captureMetadata?.componentName !== selectedCamera || !file.metadata?.timeRequested) {
+                                        return false;
+                                      }
+                                      const imgTime = file.metadata.timeRequested.toDate();
+                                      return imgTime >= passStart && imgTime <= passEnd;
+                                    }).sort((a, b) => a.metadata!.timeRequested!.toDate().getTime() - b.metadata!.timeRequested!.toDate().getTime());
                                     
-                                    // Only consider images taken after pass end, with no maximum time restriction
-                                    const afterImage = allCameraImages.find(img => {
-                                      const imgTime = img.metadata!.timeRequested!.toDate();
-                                      return imgTime > passEnd; // No maximum time restriction
-                                    });
+                                    const afterImage = allCameraImages[allCameraImages.length - 1]; // Get the last one (closest to end)
                                     
-                                    // If no image within threshold, show a message instead
-                                    if (!afterImage) {
-                                      return (
-                                        <div className="step-card" style={{ order: 999 }}>
-                                          <div className="step-name">After Image</div>
-                                          <div className="step-duration" style={{ color: '#6b7280' }}>No recent image available</div>
-                                          <div style={{ 
-                                            height: '225px',
-                                            display: 'flex',
-                                            alignItems: 'center',
-                                            justifyContent: 'center',
-                                            backgroundColor: '#f3f4f6',
-                                            borderRadius: '4px',
-                                            marginTop: '12px',
-                                            color: '#9ca3af',
-                                            fontSize: '14px'
-                                          }}>
-                                            No image captured after pass end
-                                          </div>
-                                        </div>
-                                      );
+                                    if (!afterImage || afterImage === allCameraImages[0]) {
+                                      return null; // Don't show if no image or same as start image
                                     }
                                     
                                     return (
                                       <div className="step-card" style={{ order: 999 }}>
-                                        <div className="step-name">After Image</div>
+                                        <div className="step-name">End Image</div>
                                         <div className="step-duration">
                                           {afterImage.metadata?.timeRequested?.toDate().toLocaleTimeString()}
                                           <span style={{ fontSize: '12px', color: '#6b7280', marginLeft: '8px' }}>
-                                            ({Math.round(((afterImage.metadata?.timeRequested?.toDate()?.getTime() || passEnd.getTime()) - passEnd.getTime()) / 60000)}m after pass)
+                                            ({(() => {
+                                              const minutes = Math.abs(passEnd.getTime() - afterImage.metadata?.timeRequested?.toDate()?.getTime()) / 60000;
+                                              if (minutes < 1) {
+                                                return `${Math.round(minutes * 60)}s before end`;
+                                              }
+                                              return `${Math.round(minutes)}m before end`;
+                                            })()})
                                           </span>
                                         </div>
                                         
